<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>simple demo: aframe-maze-component</title>
    <meta name="description" content="demo: aframe-maze-component">
    <script src="https://aframe.io/releases/1.1.0/aframe.min.js"></script>
    <script src="//cdn.rawgit.com/donmccurdy/aframe-extras/v3.13.1/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.6.0/dist/aframe-look-at-component.min.js"></script> 
    <script src="https://unpkg.com/aframe-maze-component@0.1.24/dist/aframe-maze-component.min.js"></script>
  </head>
  <body>
    <!-- see: https://github.com/donmccurdy/aframe-physics-system -->
  	<!-- to see wireframes, set physics='debug: true' -->
    <a-scene stats physics="debug: false">
      <a-assets>
        <img id="texture-wall" src="img/arrow-left.png">
        <img id="texture-wall-blue" src="img/arrow-left-blue.png">
        <img id="texture-wall-red" src="img/arrow-left-red.png">
        <img id="texture-floor" src="img/floor-texture-1.jpg">
        <a-box id="wall-one" 
          static-body material="src: #texture-wall" 
          depth="1" width="4" height="1"></a-box>
        <a-box id="end-cap" 
          static-body color="#444444" 
          depth="1.1" width="1.1" height="2"></a-box>
      </a-assets>
      <a-sky id="sky" color="#0000ff"></a-sky>
      <a-box id="center" 
          position="0 0 0"
          color="red" 
          depth="0.5" width="0.5" height="10"></a-box>
      <a-entity id="player"
          camera
          universal-controls
		  look-controls
          kinematic-body
          position="-20 10.8 20">
      </a-entity>
      <!-- birds-eye view box to stand on -->
      <!-- lower platform -->
      <a-box static-body 
          depth="0.25" height="1" width="1" 
          position="-20 9.8 20"
          rotation="-90 0 0"
          color="tomato"></a-box>
      <!-- maze -->
      <a-entity id="maze1" 
          maze='size: 5 6; wall: #wall-one; cap: #end-cap; open: S 0 N 1 2 4 E 5;' 
          position='0 0.5 0'
          rotation='0 0 0'></a-entity>
      <!-- ground to stand on -->
      <a-grid id="ground" width="200" height="200" static-body></a-grid>
    </a-scene>
    <!--
      <script src="js/app.js"></script>
    -->
	<script>
// ★ゲームパッドの状態を繰り返し取得する loop 関数
function loop() {
    requestAnimationFrame(loop);                    // loop 関数を繰り返す
    var pad = navigator.getGamepads();              // ゲームパッドの状態を取得
    var cam = document.getElementById("cam");       // a-camera 要素（カメラ）の取得
    var pos = cam.getAttribute("position");         // カメラの position 属性を取得
    var rot = cam.getAttribute("rotation");         // カメラの rotation 属性を取得
    var angle;                                      // カメラの角度
    if(pad[0].axes[0] <= 0) {                       // 前進時と後退時で加算する角度の正負を逆転
        angle = rot.y + 90 + pad[0].axes[1] * 45;   // 前進時はスティック値で角度を加算
    } else {
        angle = rot.y + 90 - pad[0].axes[1] * 45;   // 後退時はスティック値で角度を減算
    }
    var speed = 0.1 * pad[0].axes[0];               // スティックの前後の値で速度を決定
    pos.x -= Math.cos(angle * Math.PI / 180) * speed;   // 横方向の位置 X の計算
    pos.z += Math.sin(angle * Math.PI / 180) * speed;   // 前後方向の位置 Z の計算
    cam.setAttribute("position", pos);              // カメラの position 属性に反映
}

// loop 関数を呼ぶ処理
//window.addEventListener("gamepadconnected", loop);  // ゲームパッドが接続されたら loop 開始
//if(!window.ongamepadconnected) { loop(); }          // Chrome はイベントが起きないので直接 loop 開始

var t = 0;
var speed = 0.01;
var isIntersect = false;

AFRAME.registerComponent('collider-check', {
    dependencies: ['raycaster'],
    init: function () {
        this.el.addEventListener('raycaster-intersection', function () {
            isIntersect = true;
        });
        this.el.addEventListener('raycaster-intersection-cleared', function () {
            isIntersect = false;
        });
    }
});

function movePlayer() {
    var camera = document.getElementById('camera');

    if (camera && !isIntersect) {
        var position = camera.getAttribute('position');
        var rotation = camera.getAttribute('rotation');

        position.x += -Math.cos((rotation.y - 90) * Math.PI / 180) * speed;
        position.z += Math.sin((rotation.y - 90) * Math.PI / 180) * speed;
        camera.setAttribute('position', position);
    }
}

function render() {
    t += 0.01;
    requestAnimationFrame(render);
    movePlayer();
}
render();
</script>

	
  </body>
</html>